{"version":2,"kind":"Notebook","sha256":"416e0390c10384eafd33adce472eed3f608be8b4eb0fe3215fe80a62efd65746","slug":"gfm-maximum-flood-extent-stac","location":"/source/services/GFM/gfm_maximum_flood_extent_stac.ipynb","dependencies":[],"frontmatter":{"title":"Compute maximum flood extent utilizing STAC","subtitle":"With this notebook, we want to demo how STAC can be used to find GFM ensemble_flood_extent data and derive the maximum flood extent from it.","tags":["GFM","STAC"],"copyright":"© 2024 eodc","authors":[{"id":"Author: eodc","name":"Author: eodc"}],"license":{"content":{"id":"MIT","url":"https://opensource.org/licenses/MIT","name":"MIT License","free":true,"osi":true}},"thumbnail":"/e09f7271f6c188a68020a7d6a49ba21c.svg","kernelspec":{"name":"python3","display_name":"eodc_cluster","language":"python"},"numbering":{"title":{"offset":2}},"exports":[{"format":"ipynb","filename":"gfm_maximum_flood_extent_stac.ipynb","url":"/gfm_maximum_flood_ex-6d5fe22f3cf4f9b713582943c0a22825.ipynb"}]},"widgets":{},"mdast":{"type":"root","children":[{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Some necessary imports\n\nfrom pystac_client import Client\nfrom datetime import datetime\nfrom odc import stac as odc_stac\nimport pyproj\nimport rioxarray # noqa\nimport xarray as xr\nfrom shapely.geometry import box","key":"NBtHWPq8NL"},{"type":"output","id":"3hN3WQdWbzTKAWm_yEJCv","data":[],"key":"oTPiAiBUpC"}],"key":"tUfOHOHOBf"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Define asset name to use\nasset_name = \"ensemble_flood_extent\"\n\n# Define bounding box\naoi = box(16.77, 49.91, 18.62, 51.25)\n\n# Define time range\ntime_range = (datetime(2024, 9, 18), datetime(2024, 9, 28))\n\n# EODC STAC API URL\napi_url = \"https://stac.eodc.eu/api/v1\"\neodc_catalog = Client.open(api_url)\n\n# Define search query using pystac_client\nsearch = eodc_catalog.search(\n    max_items=1000,\n    collections=\"GFM\",\n    intersects=aoi,\n    datetime=time_range\n)\n\n# Get all found items\nitems = search.item_collection()\nprint(\"We found\", len(items), \"items, that match our filter criteria.\")","key":"n9nY3HLeeM"},{"type":"output","id":"j5gBQMlT_uAsy31nqb-Nw","data":[{"name":"stdout","output_type":"stream","text":"We found 30 items, that match our filter criteria.\n"}],"key":"jOJSjL0Vtp"}],"key":"Wc6et4p9A2"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Derive Equi7Grid CRS from first found item\ncrs = pyproj.CRS.from_wkt(items[0].properties[\"proj:wkt2\"])\n\n# Load asset data into xarray using odc-stac\n# Adjust chunk size of x/y according to available RAM\nxx = odc_stac.load(\n    items, \n    bbox=aoi.bounds,\n    crs=crs,\n    bands=[\"ensemble_flood_extent\"],\n    dtype=\"uint8\",\n    chunks={\"x\": 5000, \"y\": 5000, \"time\": -1}, \n    resolution=20)","key":"mcDFL0UyaS"},{"type":"output","id":"1xLv3ilYEGoE5w0YM6dc4","data":[],"key":"fW1r5r1KiN"}],"key":"deLfONhu7m"},{"type":"block","kind":"notebook-content","children":[{"type":"paragraph","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"children":[{"type":"text","value":"Optionally, you can save the xarray as a ZARR data store for future use. It’s important to note that the CRS (Coordinate Reference System) needs to be reapplied to the xarray after reading it.","position":{"start":{"line":1,"column":1},"end":{"line":1,"column":1}},"key":"wfRvBAlFE0"}],"key":"hPrTbqWJR9"}],"key":"Ab71J8c1yK"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Optional: Save data as ZARR data store\n# xx.to_zarr(\"./maximum_flood_data/maximum_flood.zarr\")\n\n# Read data from ZARR data store \n# xx = xr.open_zarr(\"./maximum_flood_data/maximum_flood.zarr\")\n# xx.rio.write_crs(crs, inplace=True)","key":"yieKHiQMXh"},{"type":"output","id":"snOojKeTlYGKzsfyZ7uiT","data":[],"key":"AloIoa33bo"}],"key":"WAkOazSefI"},{"type":"block","kind":"notebook-code","children":[{"type":"code","lang":"python","executable":true,"value":"# Mask out data which is nodata (255) and no-flood (0)\nxx = xx.where((xx != 255) & (xx != 0))\n\n# Calculate sum over time dimension\ndata = xx.sum(dim=\"time\").astype(\"uint8\")\n\n# Save result in current CRS (Equi7Grid)\ndata.ensemble_flood_extent.rio.to_raster(\"./maximum_flood_data/result_equi7.tif\", compress=\"LZW\")\n\n# Optional: Reproject data to WebMercator (EPSG:3857)\ndata = data.rio.reproject(\"EPSG:3857\")\ndata.ensemble_flood_extent.rio.to_raster(\"./maximum_flood_data/result_epsg3857.tif\", compress=\"LZW\")","key":"vHMca27oiF"},{"type":"output","id":"VitI_LlsuKaG29HqdB84x","data":[],"key":"LuSzmDTKjQ"}],"key":"VFKMabxIvK"}],"key":"CMnnWTAugh"},"references":{"cite":{"order":[],"data":{}}}}